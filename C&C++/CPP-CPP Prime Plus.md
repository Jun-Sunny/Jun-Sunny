

# Chapter 1

#主要介绍一些面向对象编程思想以及程序编写流程...

# Chapter 2

1. 介绍CPP编写规范
2. 引入cin和cout用法
3. 引入using namespace std

# Chapter 3

1. cout显示不同格式的整形数据, 通过给cout传入hex等控制字;
```cpp
int var = 10;
cout << hex;
cout << var; //display 0x0a
/*
hex oct dec ...
*/
```
2. const的优点
* 能够明确指明类型;
* 能够限制作用域;
* 能够作用于复杂类型;
3. auto在c中和cpp中的区别: 在c中指代局部变量,cpp中指代自动指定类型;
# Chapter 4

1. 让编译器确定数组大小
```cpp
char array[] = {1, 2};
int length = sizeof(array) / sizeof(array[0]);
```
2. 字符串[末尾具有空字符`\0`才是字符串,这点至关重要]
3. cin.get支持使用拼接方式
```cpp
cin.get(a, num).get();//前一个cin.get返回一个cin对象,从而调用下一个get
```
4. string类的使用[必须包含头文件\<string\>], string类使得可以像操纵普通变量那样操纵字符串;
5. 匿名共用体没有指定名称,但其内部变量会占据同一片内存空间;
```cpp
struct S
{
	union
	{
		int a;
		float b;
	};
}
...
struct S val;
cout << val.a;
vout << val.b; //这两个变量指向同一片内存空间
```
6. new和delete的用法
```cpp
int ptr_int = new int;//申请单个int内存指针;
int ptr_ints = new int [10];//申请连续十个int内存指针;

delete ptr_int;
delete [] ptr_ints;
```
7. 简要介绍vector容器和array类的用法
```cpp
#include <vector>
using std::vector;
vector<int> var(10); //申明十个int类型内存变量
```
# Chapter 5

1. for, while, do while...
# Chapter 6

1. 字符函数库cctype
```cpp
#include <cctype>
//包含各种字符处理函数,如大小写转换之类的
```
2. break和continue的用法,主要注意continue的用法;
3. 文件输入输出处理,包含头文件fstream(可以练习一波);
# Chapter 7

1. 函数指针
* 作为参数传递给另一个函数;
* 形成转换表;
# Chapter 8

1. 内联函数inline,注意是否内联取决于编译器,如果要强制内联,则可以使用__attribute__((always_inline))[只适用于GCC编译器];
2. 引用
* 引用必须要初始化绑定;
3. 临时变量,引用与const
* 当传入函数的实参与[const修饰的引用]形参类型不匹配时,例如传入了一个表达式,则cpp会生成一个临时变量来让引用指向,注意该临时变量只在函数运行期间存在.
* 为什么只针对const修饰的引用呢?
	在早期,任何不匹配的实参传递,都会让函数生成一个临时变量,这会导致这样一个问题.假如函数的本质是通过引用修改实参,但由于引用指向了临时变量,因此这种修改并不会改变实参.
	而如果形参使用const修饰,则代表该变量无需修改,因此生成临时变量也不影响;
* 返回引用
	注意不要返回局部变量,可以返回引用参数或者动态变量;
4. **默认参数**:注意从右到左设置默认参数,在函数声明时标注默认参数即可,定义时无需设置;
5. **函数重载**:关键在于参数数目和类型,以及排列顺序的差异,[仅仅返回值不同是不可以构成重载条件的];   本质是名称修饰,这也解释了在头文件中使用extern "C" {}修饰的原因.
6. **函数模板**泛型编程的一种
```cpp
template <typename T>
void fun(T var)
{
	T a;
}//template 和 typename是必须的, 其中template可以由class代替
```
7. 实例化和具体化
实例化可以分为隐式实例化和显式实例化,还有一种称为显式具体化,这些统称为具体化;[不是很懂,后面补充]
# Chapter 9
1. 头文件中通常包含的内容,总结的很好:
* 函数原型
* 宏定义
* 结构模板声明
* 类模板声明
* 函数模板声明
* 内联函数声明
2. cpp的编译器将使用各自的名称修饰来编译,因此在编译cpp文件时需要保证版本的一致性;
3. 存储周期,作用域和链接性
4. 名称空间:需要在外部定义
```cpp
namespace example
{
	int name1;
	float name2;
	struct name3
	{
	};
	void name4(void);
} //使用域解析运算符 :: 来使用名称空间, 或者使用using指令来简化使用
```
# Chapter 10

1. public, private, protected三种成员保护属性;
2. 类方法的几种定义方式,可以放在类模板中,也可以使用作用域解析符
```cpp
class example
{
private:
	int var0;
	int var1;

public:
	void fun0(void);
}

void example :: fun0(void)
{
	cout << this->var0 << this->var1 << endl;
}
```
2. 构造函数和析构函数
* 构造函数:用于构造新对象
```cpp
/* 假设构造了类A */
A var = var(var1, var2...);//显式利用构造函数
A var(var1, var2...);//隐式利用构造函数
A* p_var = new var(var1, var2...);//动态申请内存时调用构造函数
```
	必须要具有默认构造函数-即参数为空的构造函数
* 析构函数
析构函数在动态内存分配释放时起到非常重要的作用;
3. this指针
this指针指向用来调用成员函数的对象,作为隐藏参数进行传递,通过在成员函数括号后面加上const来将\*this限定为const
4. 类的作用域: 类中成员变量的作用域为类,这也包括符号常量等等,因此仅仅在类中使用const来定义符号常量,并不能实现一个所有对象共享的常量;解决措施是1)使用枚举(创建枚举与const不同,它不会占用实际的存储空间,而是让编译器在编译阶段就进行替换);2)使用static,从而创建静态变量,以使得所有对象共享该变量;
# Chapter 11
1. 运算符重载
```cpp
type operator+(augment);//调用时运算符左侧为默认调用方
```
运算符重载区分为两种
* 成员重载运算符函数:默认左侧操作对象为第一个参数;
* 非成员重载运算符函数:默认运算符左侧操作数为第一个参数,右边的操作数为第二个参数;
2. 友元:使得非外部对象或函数可以访问内部私密数据,需要在类声明中使用友元声明;
* 友元函数:
```cpp
friend type operator*(type para1, const type para2);
//注意,只需要在声明中标注friend,而不需要在定义中标注,除非是在类中直接进行内联定义
//另外,由于友元是针对非成员函数来说的,因此定义时并不需要使用域运算符来指明作用域
//友元函数不一定必须写在类的外面,它也可以写在类内部,使用友元函数的目的是为了规避操作数的问题
```
* 友元类;
* 友元成员函数;
3. 类型转换-针对用户自定义类型转换
# Chapter 12
1. 不要在类声明中初始化静态成员变量(这里要与[枚举变量]区分开来),即不要在类模板中初始化成员变量,因为声明只是描述内存的分配方式,而不是直接分配内存;
2. 复制构造函数,当使用一个对象来初始化另一个对象时,那么编译器将自动生成一个复制构造函数,来创建对象的一个副本来进行初始化;
这里需要探究一下cpp编译器自动提供的一些成员方法:
* 默认构造函数
* 默认析构函数
* 复制构造函数:新建一个对象,并将其初始化为同类现有对象时,将会调用复制构造函数[当对象被创建时如果调用默认复制构造函数,就不会使用默认构造函数,这样一些功能可能就无法实现];
```cpp
class_name(const class_name &);//创建一个指向类对象的常量引用
```
* 赋值运算符
* 地址运算符
3. 静态成员函数: 静态成员函数不能被特定对象调用,但可以使用域解析符调用,并且静态成员函数只能使用静态成员变量;
4. 提高cpp运行效率的一个关键点在于如何减少临时变量的使用,这可能涉及声明时相关变量的类型定义;
